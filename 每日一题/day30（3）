在矩阵中查找路径
"ABCE"
"SFCS"
"ADEE"

"ABCCED"   ---> true
"SEE"     ----> true
"ABCB"    ----> false


//方法2
bool hasPathCore(vector<vector<char>>& board,int rows,int cols,\
	int row,int col,string str,int& pathlength,bool* visited)
{
	if (str[pathlength] == '\0')
		return true;
	bool hasPath = false;
	if (row >= 0 && row < rows&&col >= 0 && col < cols&&board[row][col] == str[pathlength] && !visited[row*cols + col])
	{
		pathlength++;
		visited[row*cols + col] = true;
		hasPath = hasPathCore(board, rows, cols, row, col - 1, str, pathlength, visited) ||
			hasPathCore(board, rows, cols, row - 1, col, str, pathlength, visited) ||
			hasPathCore(board, rows, cols, row, col + 1, str, pathlength, visited) ||
			hasPathCore(board, rows, cols, row + 1, col, str, pathlength, visited);
		if (!hasPath)
		{
			pathlength--;
			visited[row*cols + col] = false;
		}
	}
	return hasPath;
}

bool exist2(vector<vector<char>>& board, string word)
{
	int rows = board.size();
	int cols = board[0].size();
	if (rows == 0 || cols == 0 || word.size() == 0)
		return false;
	bool* visited = new bool[rows*cols];
	memset(visited,0,rows*cols);

	int pathlength = 0;
	for (int row = 0; row < rows;row++)
	{
		for (int col = 0; col < cols; col++)
		{
			if (hasPathCore(board, rows, cols, row, col, word, pathlength, visited))
			{
				return true;
			}
		}
	}
	delete[] visited;
	return false;
}
int main()
{
	char arr[][5] = { "ABCE", "SFCS", "ADEE" };
	char*ch = "ABC";
	string key(ch,6);
	vector<char> t1;
	vector<vector<char>> str;
	for (int i = 0; i < 3; i++)
	{
		str.push_back(t1);
	}
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			str[i].push_back(arr[i][j]);
		}
	}

	if (exist2(str, key))
		cout << "true" << endl;
	else
		cout << "false" << endl;

	system("pause");
	return 0;
}
